// NOTE: This shader requires being manually compiled to SPIR-V in order to
// avoid having downstream users require building shaderc and compiling the
// shader themselves. If you update this shader, be sure to also re-compile it
// and update `comp.spv`. You can do so using `glslangValidator` with the
// following command: `glslangValidator -V shader.comp`
#version 450

precision highp int;
precision mediump float;

layout(local_size_x = 1) in;

layout(set = 0, binding = 0) buffer PositionBufferIn { vec2[] positions_in; };

layout(set = 0, binding = 1) buffer PositionBufferOut { vec2[] positions_out; };

layout(set = 0, binding = 2) buffer VelocityBuffer { vec2[] velocities; };

layout(set = 0, binding = 3) uniform Uniforms {
    uint particle_count;
    float width;
    float height;
    float speed;
    float attraction_strength;
    float attraction_range;
    float repulsion_strength;
    float repulsion_range;
    float center_strength;
    float particle_radius;
    float collision_response;
    float momentum;
};

void main() {
    // get particle data
    uint index = gl_GlobalInvocationID.x;
    vec2 position = positions_in[index];
    vec2 velocity = velocities[index];
    vec2 acceleration = vec2(0.0, 0.0);

    float radius2 = particle_radius * 2.0;

    // loop through every other
    for (uint i = 0; i < particle_count; i++) {
        if (i == index) {
            continue;
        }

        vec2 other_position = positions_in[i];
        vec2 diff = other_position - position;
        float dist = length(diff);

        // determine force to apply
        if (dist >= 0.5) {
            vec2 dir = normalize(diff);
            float r2 = dist * dist;

            if (attraction_range == 0.0 || dist <= attraction_range) {
                acceleration += dir * attraction_strength / r2;
            }

            if (repulsion_range == 0.0 || dist <= repulsion_range) {
                acceleration += -dir * repulsion_strength / r2;
            }
        }

        // detect collisions
        if (dist < radius2) {
            vec2 mv = diff * (-(radius2 - dist));
            velocity += mv * collision_response;
        }
    }

    // attract to center
    acceleration += position * -center_strength;

    // clamp acceleration for stability
    float max_acceleration = 1.0;
    acceleration = clamp(acceleration, -max_acceleration, max_acceleration);

    velocity *= momentum;
    velocity += acceleration * speed;

    // clamp velocity
    float max_velocity = 1.0;
    velocity = clamp(velocity, -max_velocity, max_velocity);

    position += velocity * speed;

    // // wrap around horizontally
    // float hwidth = width * 0.5;
    // if (position.x < -hwidth) {
    //     position.x += width;
    // } else if (position.x > hwidth) {
    //     position.x -= width;
    // }

    // // wrap around vertically
    // float hheight = height * 0.5;
    // if (position.y < -hheight) {
    //     position.y += height;
    // } else if (position.y > hheight) {
    //     position.y -= height;
    // }

    // update buffers
    velocities[index] = velocity;
    positions_out[index] = position;
}
