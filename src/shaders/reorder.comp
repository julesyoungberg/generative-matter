#version 450

precision highp int;
precision mediump float;

layout(local_size_x = 1) in;

layout(set = 0, binding = 0) buffer PositionInBuffer { vec2[] positions_in; };
layout(set = 0, binding = 1) buffer PositionOutBuffer { vec2[] positions_out; };
layout(set = 0, binding = 2) buffer VelocityInBuffer { vec2[] velocities_in; };
layout(set = 0, binding = 3) buffer VelocityOutBuffer {
    vec2[] velocities_out;
};
layout(set = 0, binding = 4) buffer PrefixBuffer { uint[] prefix_sums; };
layout(set = 0, binding = 5) buffer BinCountBuffer { uint[] bin_counts; };
layout(set = 0, binding = 6) uniform Uniforms {
    uint particle_count;
    float width;
    float height;
    float speed;
    float attraction_strength;
    float repulsion_strength;
    float attraction_range;
    float repulsion_range;
    float center_strength;
    float particle_radius;
    float collision_response;
    float momentum;
    float max_acceleration;
    float max_velocity;
    uint num_bins_x;
    uint num_bins_y;
    float bin_size_x;
    float bin_size_y;
    uint num_bins;
};

// Reorder the particles so that they are sorted according to radix sort.
void main() {
    // read position
    uint index = gl_GlobalInvocationID.x;
    vec2 position = positions_in[index];

    // make position positive
    position += vec2(width, height) * 0.5;

    // get bin index
    ivec2 bin = ivec2(floor(position / vec2(bin_size_x, bin_size_y)));
    uint bin_index =
        clamp(uint(bin.y) * num_bins_x + uint(bin.x), 0, num_bins - 1);

    // get new particle index
    uint bin_start_index = prefix_sums[bin_index];
    uint num_before = atomicAdd(bin_counts[bin_index], 1);
    uint new_index = bin_start_index + num_before;

    // output particle to correct position in buffer
    positions_out[new_index] = positions_in[index];
    velocities_out[new_index] = velocities_in[index];
}
